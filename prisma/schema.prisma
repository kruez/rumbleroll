generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String?
  password        String
  isAdmin         Boolean   @default(false)
  venmoHandle     String?
  cashAppHandle   String?
  profileImageUrl String?
  bio             String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  hostedParties    Party[]            @relation("HostedParties")
  participations   PartyParticipant[]
}

model RumbleEvent {
  id          String      @id @default(cuid())
  name        String      // "Royal Rumble 2025"
  year        Int
  isTest      Boolean     @default(false)
  status      EventStatus @default(NOT_STARTED)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  entries     RumbleEntry[]
  parties     Party[]
}

enum EventStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

model Party {
  id          String      @id @default(cuid())
  name        String
  inviteCode  String      @unique
  status      PartyStatus @default(LOBBY)
  entryFee    Float?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  hostId       String
  host         User        @relation("HostedParties", fields: [hostId], references: [id])

  eventId      String
  event        RumbleEvent @relation(fields: [eventId], references: [id])

  participants PartyParticipant[]
  assignments  NumberAssignment[]
}

enum PartyStatus {
  LOBBY
  NUMBERS_ASSIGNED
  COMPLETED
}

model PartyParticipant {
  id        String   @id @default(cuid())
  joinedAt  DateTime @default(now())
  hasPaid   Boolean  @default(false)
  paidAt    DateTime?

  partyId   String
  party     Party  @relation(fields: [partyId], references: [id], onDelete: Cascade)

  userId    String
  user      User   @relation(fields: [userId], references: [id])

  assignments NumberAssignment[]

  @@unique([partyId, userId])
}

model NumberAssignment {
  id          String @id @default(cuid())
  entryNumber Int    // 1-30

  participantId String
  participant   PartyParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  partyId     String
  party       Party  @relation(fields: [partyId], references: [id], onDelete: Cascade)

  @@unique([partyId, entryNumber])
}

model RumbleEntry {
  id               String    @id @default(cuid())
  entryNumber      Int       // 1-30
  wrestlerName     String?
  wrestlerImageUrl String?   // WWE CDN URL for wrestler photo
  enteredAt        DateTime?
  eliminatedAt     DateTime?
  eliminatedBy     String?   // Name of wrestler who eliminated them
  isWinner         Boolean   @default(false)

  eventId          String
  event            RumbleEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, entryNumber])
}

model Wrestler {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique  // "drew-mcintyre"
  imageUrl  String?            // WWE CDN URL
  brand     String?            // "Raw", "SmackDown", "NXT"
  source    String             // "wwe"
  sourceId  String?
  isActive  Boolean  @default(true)
  aliases   String[]           // For fuzzy matching
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([brand])
  @@index([isActive])
}

model ScrapeCacheMetadata {
  id            String   @id @default(cuid())
  source        String   @unique  // "wwe"
  lastScrapedAt DateTime
  totalCount    Int
  status        String             // "success", "partial", "failed"
  errorMessage  String?
}
